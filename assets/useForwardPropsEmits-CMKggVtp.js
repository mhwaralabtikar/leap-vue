import{c as S,k as U,i as $,d as w}from"./useForwardExpose-L0rcEWKp.js";import{au as C,r as h,w as E,ad as k,Z as x,h as M,d as F,M as _,ao as g,a9 as j,av as D,aw as O,am as L}from"./index-Ck4Sddnw.js";import{r as R}from"./index-bMUsnnO9.js";const[V,X]=S("ConfigProvider");let B=0;function W(i,e="reka"){const t=V({useId:void 0});return C?`${e}-${C()}`:t.useId?`${e}-${t.useId()}`:`${e}-${++B}`}function q(i,e){const t=h(i);function c(o){return e[t.value][o]??t.value}return{state:t,dispatch:o=>{t.value=c(o)}}}function z(i,e){var N;const t=h({}),c=h("none"),l=h(i),o=i.value?"mounted":"unmounted";let n;const r=((N=e.value)==null?void 0:N.ownerDocument.defaultView)??U,{state:d,dispatch:f}=q(o,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),m=a=>{var s;if($){const v=new CustomEvent(a,{bubbles:!1,cancelable:!1});(s=e.value)==null||s.dispatchEvent(v)}};E(i,async(a,s)=>{var y;const v=s!==a;if(await k(),v){const P=c.value,p=A(e.value);a?(f("MOUNT"),m("enter"),p==="none"&&m("after-enter")):p==="none"||p==="undefined"||((y=t.value)==null?void 0:y.display)==="none"?(f("UNMOUNT"),m("leave"),m("after-leave")):s&&P!==p?(f("ANIMATION_OUT"),m("leave")):(f("UNMOUNT"),m("after-leave"))}},{immediate:!0});const u=a=>{const s=A(e.value),v=s.includes(a.animationName),y=d.value==="mounted"?"enter":"leave";if(a.target===e.value&&v&&(m(`after-${y}`),f("ANIMATION_END"),!l.value)){const P=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",n=r==null?void 0:r.setTimeout(()=>{var p;((p=e.value)==null?void 0:p.style.animationFillMode)==="forwards"&&(e.value.style.animationFillMode=P)})}a.target===e.value&&s==="none"&&f("ANIMATION_END")},I=a=>{a.target===e.value&&(c.value=A(e.value))},T=E(e,(a,s)=>{a?(t.value=getComputedStyle(a),a.addEventListener("animationstart",I),a.addEventListener("animationcancel",u),a.addEventListener("animationend",u)):(f("ANIMATION_END"),n!==void 0&&(r==null||r.clearTimeout(n)),s==null||s.removeEventListener("animationstart",I),s==null||s.removeEventListener("animationcancel",u),s==null||s.removeEventListener("animationend",u))},{immediate:!0}),b=E(d,()=>{const a=A(e.value);c.value=d.value==="mounted"?a:"none"});return x(()=>{T(),b()}),{isPresent:M(()=>["mounted","unmountSuspended"].includes(d.value))}}function A(i){return i&&getComputedStyle(i).animationName||"none"}const ee=F({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(i,{slots:e,expose:t}){var f;const{present:c,forceMount:l}=_(i),o=h(),{isPresent:n}=z(c,o);t({present:n});let r=e.default({present:n.value});r=R(r||[]);const d=g();if(r&&(r==null?void 0:r.length)>1){const m=(f=d==null?void 0:d.parent)!=null&&f.type.name?`<${d.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${m}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(u=>`  - ${u}`).join(`
`)].join(`
`))}return()=>l.value||c.value||n.value?j(e.default({present:n.value})[0],{ref:m=>{const u=w(m);return typeof(u==null?void 0:u.hasAttribute)>"u"||(u!=null&&u.hasAttribute("data-reka-popper-content-wrapper")?o.value=u.firstElementChild:o.value=u),u}}):null}});function H(i){const e=g(),t=e==null?void 0:e.type.emits,c={};return t!=null&&t.length||console.warn(`No emitted event found. Please check component: ${e==null?void 0:e.type.__name}`),t==null||t.forEach(l=>{c[D(O(l))]=(...o)=>i(l,...o)}),c}function K(i){const e=g(),t=Object.keys((e==null?void 0:e.type.props)??{}).reduce((l,o)=>{const n=(e==null?void 0:e.type.props[o]).default;return n!==void 0&&(l[o]=n),l},{}),c=L(i);return M(()=>{const l={},o=(e==null?void 0:e.vnode.props)??{};return Object.keys(o).forEach(n=>{l[O(n)]=o[n]}),Object.keys({...t,...l}).reduce((n,r)=>(c.value[r]!==void 0&&(n[r]=c.value[r]),n),{})})}function te(i,e){const t=K(i),c=e?H(e):{};return M(()=>({...t.value,...c}))}export{ee as P,te as a,K as b,H as c,V as i,W as u};
